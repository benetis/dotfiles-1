;; -*- mode: emacs-lisp -*-

(use-package org
  :mode ("\\.org\\'" . org-mode)

  :bind (("C-c a" . org-agenda)
         ("C-c c" . org-capture)
         ("C-c l" . org-store-link)
         :map org-mode-map
         ("C-c C-a" . michalrus/org-archive-done-tasks-in-file)
         ("C-c C-v" . org-tasklist-set-priority))

  :config
  (setq org-directory "~/Org")

  (setq-default
     org-reverse-note-order t
     org-refile-targets '((nil . (:maxlevel . 4)))
     org-refile-use-outline-path t
     org-todo-keywords '((sequence "TODO(t!)" "IN-PROGRESS(i!)" "WAITING(w@)" "|" "DONE(d!)" "DELEGATED(g@)" "CANCELED(c@)"))
     org-log-into-drawer t
     org-startup-indented t
     org-log-done nil
     org-support-shift-select t
     org-catch-invisible-edits 'error
     org-ctrl-k-protect-subtree 'error)

  (use-package org-id
    :init
    (setq org-id-link-to-org-use-id t))

  (use-package org-agenda
    :bind (:map org-agenda-mode-map
           ("C-c C-v" . org-tasklist-agenda-set-priority)))

  (setq org-default-notes-file (expand-file-name "Inbox.org" org-directory))
  ;; Unbind S-left/right, because I’m logging every state change!
  (dolist (dir '("left" "right"))
    (define-key org-mode-map (kbd (format "S-<%s>" dir)) nil))
  (setq org-clock-persist 'history)
  (org-clock-persistence-insinuate)

  ;; ——————————————————— org-tasklist sketch (BEGIN) ———————————————————

  (setq org-agenda-custom-commands
        '(("t" "Tasklist" alltodo ""
           ((org-agenda-files '("~/Org/Tasklist.org"))
            (org-agenda-todo-list-sublevels nil)
            (org-agenda-prefix-format
             (let ((cpy (copy-alist org-agenda-prefix-format)))
               (progn (setcdr (assq 'todo cpy)
                              "%(org-tasklist--agenda-prefix-format)  %-11:c  ")
                      cpy)))
            (org-agenda-sorting-strategy '(user-defined-down))
            (org-agenda-cmp-user-defined 'org-tasklist--agenda-sorting-cmp)
            ))))

  (defun org-tasklist--is-1st-level-task-p (pom)
    "Will return `t' iff the task at `pom' is a TODO/DONE/… at the first level, i.e. not a subtask of another TODO/DONE/…, `nil' otherwise."
    (interactive (list (point)))
    (save-excursion
      (goto-char pom)
      (and (or (org-entry-is-todo-p)
               (org-entry-is-done-p))
           (or (eq (org-current-level) 1)
               (let* ((check-parent (lambda ()
                                      (save-excursion
                                        (let ((point-was-at (point)))
                                          (condition-case nil
                                              (outline-up-heading 1 t)
                                            (error nil))
                                          (cond ((or (org-entry-is-done-p) (org-entry-is-todo-p)) nil)
                                                ((eq (point) point-was-at) t)
                                                (t (funcall check-parent))))))))
                 (funcall check-parent))))))

  (defun org-tasklist--get-priority (pom)
    (let ((value      (org-entry-get (point) "TASKLIST_VALUE"))
          (investment (org-entry-get (point) "TASKLIST_INVESTMENT")))
      (cond ((and value investment)
             (let ((nvalue (float (string-to-number value)))
                   (ninvestment (float (string-to-number investment))))
               (/ nvalue ninvestment)))
            (t nil))))

  (defun org-tasklist--agenda-prefix-format ()
    (let ((prio (org-tasklist--get-priority (point))))
      (cond (prio
             (let (;; TODO: read units & labels from :PROPERTIES:
                   (unit-value "$")
                   (unit-investment "hr"))
               (format "%6.02f %s/%s"
                       prio
                       (substring unit-value 0 1)
                       (substring unit-investment 0 1))))
            (t (format "%6s %3s" "——" "")))))

  (defun org-tasklist--agenda-sorting-cmp (a b)
    "Sorts agenda entries according to their tasklist priorities. Hacky—relies on entry formatting (priority being the first number) for performance."
    (let ((pa (string-to-number (or (car (split-string a)) "0")))
          (pb (string-to-number (or (car (split-string b)) "0"))))
      (cond ((eq pa pb) nil)
            ((eq 0 pa) 1)
            ((eq 0 pb) -1)
            ((< pa pb) -1)
            (t 1))))

  (defun org-tasklist-set-priority (pom)
    "Set tasklist priority for the current headline."
    (interactive (list (point)))
    (unless (org-tasklist--is-1st-level-task-p pom)
      (error (format "Entry at %d is not a 1st-level task, aborting" pom)))
    (let* ((read-num (lambda (label unit default)
                       (let* ((str (read-string (format "%s [%s] (%f): " label unit default)
                                                nil nil (number-to-string default)))
                              (num (string-to-number str)))
                         (if (eq num 0) (error (format "%s [%s] must be a non-zero number, got ‘%s’" label unit str))) num)))
           ;; TODO: read units & labels from :PROPERTIES:
           (value      (funcall read-num "value" "$" 25.0))
           (investment (funcall read-num "time"  "hr" 0.5)))
      (org-entry-put pom "TASKLIST_VALUE" (number-to-string value))
      (org-entry-put pom "TASKLIST_INVESTMENT" (number-to-string investment))))

  (defun org-tasklist-agenda-set-priority ()
    "Set tasklist priority for the current headline."
    (interactive)
    (org-agenda-check-no-diary)
    (let* ((hdmarker (or (org-get-at-bol 'org-hd-marker)
                         (org-agenda-error)))
           (buffer (marker-buffer hdmarker))
           (pos (marker-position hdmarker))
           (inhibit-read-only t)
           newhead)
      (org-with-remote-undo buffer
        (with-current-buffer buffer
          (widen)
          (goto-char pos)
          (save-excursion
            (org-show-context 'agenda))
          (save-excursion
            (and (outline-next-heading)
                 (org-flag-heading nil)))   ; show the next heading
          (goto-char pos)
          (call-interactively 'org-tasklist-set-priority))))
    (org-agenda-redo t))

  ;; ——————————————————— org-tasklist sketch (END) ———————————————————

  (defun michalrus/org-archive-done-tasks-in-file ()
    "Archives all done tasks in the current Org file to their “Archive” siblings"
    (interactive)
    (org-map-entries
     (lambda ()
       (let ((entry-tags (upcase (or (org-entry-get (point) "ALLTAGS") ""))))
         (cond ((or (string-match-p ":ARCHIVE:"  entry-tags)
                    (string-match-p ":SKIP_ARCHIVE:" entry-tags))
                ;; Sometimes we’re left with (point) at an :ARCHIVE: after
                ;; (org-archive-to-archive-sibling) returns and this slips
                ;; through the 'archive filter of (org-map-entries), and
                ;; results in an infinite recursion, so… yeah. Let’s
                ;; recheck manually and skip the archived subtree.
                (setq org-map-continue-from (+ 1 (save-excursion (org-end-of-subtree t)))))
               ((org-entry-is-done-p)
                (let ((point-was-at (point)))
                  (org-archive-to-archive-sibling)
                  ;; Continue mapping at where the archived entry was,
                  ;; because the next one (its ex-sibling) might need
                  ;; archiving, too.
                  (setq org-map-continue-from point-was-at))))))
     t 'file 'archive)))
