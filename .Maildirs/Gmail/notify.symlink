#!/usr/bin/env perl

use strict;
use warnings;
use utf8;

use threads;
use Thread::Queue;

use Config::Tiny;
use Cwd 'abs_path';
use Data::Dumper;
use FindBin qw($Bin $Script);
use JSON;
use LWP::UserAgent;
use URI;

my $maildir = $Bin;

my $config;
sub config_read  { $config = Config::Tiny->read($Script . '.conf', 'utf8'); }
sub config_write { $config->write(              $Script . '.conf', 'utf8'); }
config_read;

my $ua = LWP::UserAgent->new(ssl_opts => { verify_hostname => 1 });

sub access_token {
    my ($rt) = $$config{runtime};
    my ($ga) = $$config{'google-api'};
    if (defined $rt->{expires_on} && time < $rt->{expires_on}) { # access_token still valid
        return $rt->{access_token};
    } elsif (defined $rt->{refresh_token}) { # refreshing access_token
        my $token_req = decode_json($ua->post('https://www.googleapis.com/oauth2/v4/token', {
            'refresh_token' => $rt->{refresh_token},
            'client_id' => $ga->{client_id}, 'client_secret' => $ga->{client_secret},
            'grant_type' => 'refresh_token' })->content);
        $rt->{access_token} = $token_req->{access_token};
        $rt->{expires_on} = time + $token_req->{expires_in};
        config_write;
        return $rt->{access_token};
    } else { # full auth
        my $uri = URI->new('https://accounts.google.com/o/oauth2/v2/auth');
        $uri->query_form({
            'response_type' => 'code',
            'client_id' => $ga->{client_id},
            'redirect_uri' => 'urn:ietf:wg:oauth:2.0:oob',
            'scope' => 'https://www.googleapis.com/auth/gmail.readonly'});
        print('Go to ' . $uri->as_string . " and paste the code here:\n");
        my $auth_code = <>; chomp $auth_code;
        my $token_req = decode_json($ua->post('https://www.googleapis.com/oauth2/v4/token', {
            'code' => $auth_code,
            'client_id' => $ga->{client_id}, 'client_secret' => $ga->{client_secret},
            'redirect_uri' => 'urn:ietf:wg:oauth:2.0:oob',
            'grant_type' => 'authorization_code' })->content);
        $rt->{access_token} = $token_req->{access_token};
        $rt->{expires_on} = time + $token_req->{expires_in};
        $rt->{refresh_token} = $token_req->{refresh_token};
        config_write;
        return $rt->{access_token};
    }
}

my $q_inbox = Thread::Queue->new();

my $thr_monitor_remote = threads->create(sub {
    my ($rt) = $$config{runtime};
    local *ask = sub {
        my ($path, $query) = @_;
        my $uri = URI->new('https://www.googleapis.com/gmail/v1/users/me/' . $path);
        $uri->query_form($query);
        return decode_json($ua->get($uri, 'GData-Version' => '3.0', 'Authorization' => 'Bearer ' . access_token)->content);
    };
    unless (defined $rt->{history_id}) {
        $rt->{history_id} = ask('threads', { 'maxResults' => 1, 'includeSpamTrash' => 'true' })->{threads}[0]->{historyId};;
        config_write;
    }
    unless (defined $rt->{last_sync}) {
        $rt->{last_sync} = 0;
        config_write;
    }
    for (;;) { eval { # ignore errors any in each iteration; just print them and reiterate
        print "asking for /history...\n";
        my $new_history = [];
        for (;;) { # slurp all available data
            my $resp = ask('history', { 'maxResults' => 100, 'startHistoryId' => $rt->{history_id} });
            $rt->{history_id} = $resp->{historyId};
            last unless (defined $resp->{history});
            push @$new_history, @{ $resp->{history} };
        }
        config_write;
        my $some_touched = 0;
        my $notifications = [];
        foreach my $entry (@{ $new_history }) {
            local *labels_match = sub {
                my ($ids) = @_;
                return (defined $ids && grep(/^(INBOX|DRAFT)$/, @{ $ids }));
            };
            local *handle_msg = sub {
                my ($labels, $id, $notify) = @_;
                if (labels_match($labels)) {
                    $some_touched = 1;
                    if ($notify == 1) {
                        push @$notifications, $id;
                    } elsif ($notify == -1) {
                        # don't show notifications for new messages that are already deleted
                        @$notifications = grep { !($_ eq $id) } @$notifications;
                    }
                }
            };
            local *check_touched = sub {
                my ($key, $go_deeper, $notify) = @_;
                if (defined $entry->{$key}) {
                    foreach my $msg (@{ $entry->{$key} }) {
                        $msg = $msg->{message} if $go_deeper;
                        handle_msg($msg->{labelIds}, $msg->{id}, $notify);
                    }
                }
            };
            check_touched('messages',        0,  0);
            check_touched('messagesAdded',   1,  1);
            check_touched('messagesDeleted', 1, -1);
        }
        if ($some_touched) {
            local *uniq = sub {
                my %seen;
                grep !$seen{$_}++, @_;
            };
            @$notifications = uniq(@$notifications);
            my $notificationsFull = [];
            foreach my $id (@$notifications) {
                my $fmsg = ask('messages/' . $id, { 'format' => 'metadata' });
                my $snippet = $fmsg->{snippet};
                my $from = '?'; my $subject = '?';
                foreach my $h (@{ $fmsg->{payload}->{headers} }) {
                    $from    = $h->{value} if $h->{name} eq 'From';
                    $subject = $h->{value} if $h->{name} eq 'Subject';
                }
                push @$notificationsFull, { 'from' => $from, 'subject' => $subject, 'snippet' => $snippet };
            }
            $q_inbox->enqueue($notificationsFull);
        }
    } or do { print STDERR $@; }; sleep(3); }
});

my $thr_sync_inbox = threads->create(sub {
    while (defined (my $msgs = $q_inbox->dequeue())) {
        print(Dumper($msgs));
        local *es = sub {
            my ($s) = @_;
            $s =~ s/</&lt;/g;
            $s =~ s/>/&gt;/g;
            return $s;
        };
        foreach my $msg (@$msgs) {
            system('notify-send', "From:\t" . es($msg->{from}), "<b>Subject:\t" . es($msg->{subject}) . "</b>\n\n" . es($msg->{snippet}));
        }
    }
});

$thr_monitor_remote->join();
$thr_sync_inbox->join();
